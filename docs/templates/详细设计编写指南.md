# 详细设计说明书编写指南 (LLD)

---

## 核心理念

### LLD 的定位

| 文档 | 回答什么 | 粒度 |
|------|----------|------|
| 架构设计 | 为什么这样设计？ | 战略 |
| 概要设计 (HLD) | 系统由哪些部分组成？ | 战术 |
| **详细设计 (LLD)** | **具体怎么实现？** | **执行** |

### LLD 的核心内容

1. **模块内部结构**：函数签名、类型定义、依赖关系
2. **算法与逻辑**：核心算法、状态机、决策树
3. **数据结构**：内存布局、缓存策略、索引设计
4. **错误处理**：错误分类、恢复策略、重试逻辑

### 小团队原则

- **代码即文档**：类型签名 + 注释 > 独立文档
- **关键路径优先**：只详细设计复杂/核心模块
- **可执行示例**：伪代码能直接转为实现

---

## 文档结构

```
lld.md
├── 1. 模块总览       → 模块列表和依赖
├── 2. 核心模块设计   → 逐个模块详细设计
├── 3. 公共组件       → 复用的工具和抽象
├── 4. 错误处理       → 统一错误策略
└── 5. 测试策略       → 如何验证实现
```

---

## 完整模板

### 1. 模块总览

#### 1.1 模块依赖图

```
┌─────────────────────────────────────────────────────┐
│                      main.rs                        │
│                    (组装入口)                        │
└─────────┬─────────────┬─────────────┬───────────────┘
          │             │             │
          ▼             ▼             ▼
     ┌─────────┐   ┌─────────┐   ┌─────────┐
     │   api   │   │ service │   │  infra  │
     └────┬────┘   └────┬────┘   └────┬────┘
          │             │             │
          │             ▼             │
          │       ┌─────────┐         │
          └──────▶│ domain  │◀────────┘
                  └─────────┘
```

#### 1.2 模块清单

| 模块 | 路径 | 职责 | 复杂度 | 需详细设计 |
|------|------|------|--------|------------|
| api | `src/api/` | HTTP 处理 | 低 | ✗ |
| service | `src/service/` | 业务逻辑 | 高 | ✓ |
| repository | `src/repository/` | 数据访问 | 中 | ✓ |
| domain | `src/domain/` | 核心实体 | 中 | ✓ |
| infra | `src/infra/` | 基础设施 | 低 | ✗ |

---

### 2. 核心模块设计

#### 2.1 用户认证模块

##### 2.1.1 模块概述

```
src/service/auth_service.rs
├── 注册流程
├── 登录流程
├── Token 管理
└── 密码重置
```

##### 2.1.2 类型定义

```rust
/// 认证服务
pub struct AuthService {
    user_repo: Arc<dyn UserRepository>,
    password_hasher: PasswordHasher,
    jwt_service: JwtService,
    cache: Arc<dyn Cache>,
}

/// 登录结果
pub struct LoginResult {
    pub user: UserResponse,
    pub access_token: String,
    pub refresh_token: String,
    pub expires_in: i64,
}

/// 认证错误
pub enum AuthError {
    InvalidCredentials,      // 用户名或密码错误
    UserNotFound,            // 用户不存在
    UserDisabled,            // 用户被禁用
    TokenExpired,            // Token 过期
    TokenInvalid,            // Token 无效
    TooManyAttempts,         // 尝试次数过多
}
```

##### 2.1.3 核心算法：登录流程

```rust
/// 登录流程
/// 
/// 时间复杂度: O(1) 数据库查询 + O(n) 密码验证
/// 空间复杂度: O(1)
pub async fn login(&self, req: LoginRequest) -> Result<LoginResult, AuthError> {
    // 1. 检查登录频率限制
    //    Key: login_attempts:{ip}:{username}
    //    规则: 5次/分钟，超过锁定15分钟
    let rate_key = format!("login_attempts:{}:{}", req.ip, req.username);
    if self.cache.get_count(&rate_key).await? >= 5 {
        return Err(AuthError::TooManyAttempts);
    }

    // 2. 查询用户
    let user = self.user_repo
        .find_by_username(&req.username)
        .await?
        .ok_or(AuthError::InvalidCredentials)?;  // 不暴露用户是否存在

    // 3. 检查用户状态
    if user.status != UserStatus::Active {
        return Err(AuthError::UserDisabled);
    }

    // 4. 验证密码 (Argon2id, ~100ms)
    if !self.password_hasher.verify(&req.password, &user.password_hash)? {
        // 记录失败次数
        self.cache.incr(&rate_key, 60).await?;
        return Err(AuthError::InvalidCredentials);
    }

    // 5. 生成 Token
    let access_token = self.jwt_service.create_access_token(&user)?;
    let refresh_token = self.jwt_service.create_refresh_token(&user)?;

    // 6. 清除失败计数
    self.cache.del(&rate_key).await?;

    // 7. 记录登录日志 (异步，不阻塞响应)
    tokio::spawn(self.log_login(user.id, req.ip.clone()));

    Ok(LoginResult {
        user: user.into(),
        access_token,
        refresh_token,
        expires_in: 1800, // 30 分钟
    })
}
```

##### 2.1.4 状态图：用户状态流转

```
                    ┌─────────┐
                    │ Created │
                    └────┬────┘
                         │ 邮箱验证
                         ▼
     ┌──────────────┬─────────┬──────────────┐
     │              │ Active  │              │
     │              └────┬────┘              │
     │                   │                   │
     │ 用户禁用          │ 用户删除          │ 长期未登录
     ▼                   ▼                   ▼
┌─────────┐        ┌─────────┐        ┌──────────┐
│ Disabled │        │ Deleted │        │ Inactive │
└─────────┘        └─────────┘        └──────────┘
     │                                       │
     │ 管理员恢复                             │ 重新登录
     └───────────────────┬───────────────────┘
                         ▼
                    ┌─────────┐
                    │ Active  │
                    └─────────┘
```

---

#### 2.2 订单处理模块

##### 2.2.1 模块概述

```
src/service/order_service.rs
├── 创建订单
├── 订单支付
├── 订单取消
└── 订单状态机
```

##### 2.2.2 状态机定义

```rust
/// 订单状态
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum OrderStatus {
    Pending,     // 待支付
    Paid,        // 已支付
    Processing,  // 处理中
    Shipped,     // 已发货
    Completed,   // 已完成
    Cancelled,   // 已取消
    Refunded,    // 已退款
}

/// 订单事件
pub enum OrderEvent {
    Pay,         // 支付
    Process,     // 开始处理
    Ship,        // 发货
    Complete,    // 完成
    Cancel,      // 取消
    Refund,      // 退款
}

/// 状态转换表
impl OrderStatus {
    pub fn can_transition(&self, event: &OrderEvent) -> Option<OrderStatus> {
        match (self, event) {
            // 待支付 -> 已支付 | 已取消
            (Pending, OrderEvent::Pay)      => Some(Paid),
            (Pending, OrderEvent::Cancel)   => Some(Cancelled),
            
            // 已支付 -> 处理中 | 已退款
            (Paid, OrderEvent::Process)     => Some(Processing),
            (Paid, OrderEvent::Refund)      => Some(Refunded),
            
            // 处理中 -> 已发货
            (Processing, OrderEvent::Ship)  => Some(Shipped),
            
            // 已发货 -> 已完成
            (Shipped, OrderEvent::Complete) => Some(Completed),
            
            // 其他转换不允许
            _ => None,
        }
    }
}
```

##### 2.2.3 核心算法：创建订单

```rust
/// 创建订单
/// 
/// 事务保证: 订单创建和库存扣减在同一事务
/// 并发控制: 使用 SELECT FOR UPDATE 锁定库存
pub async fn create_order(&self, req: CreateOrderRequest) -> Result<Order, OrderError> {
    // 开启事务
    let mut tx = self.pool.begin().await?;

    // 1. 验证商品并锁定库存
    let mut total_amount = Decimal::ZERO;
    let mut order_items = Vec::with_capacity(req.items.len());

    for item in &req.items {
        // SELECT ... FOR UPDATE 防止超卖
        let product = sqlx::query_as!(
            Product,
            r#"
            SELECT id, name, price, stock 
            FROM products 
            WHERE id = $1 
            FOR UPDATE
            "#,
            item.product_id
        )
        .fetch_optional(&mut *tx)
        .await?
        .ok_or(OrderError::ProductNotFound(item.product_id))?;

        // 检查库存
        if product.stock < item.quantity {
            return Err(OrderError::InsufficientStock {
                product_id: item.product_id,
                available: product.stock,
                requested: item.quantity,
            });
        }

        // 扣减库存
        sqlx::query!(
            "UPDATE products SET stock = stock - $1 WHERE id = $2",
            item.quantity,
            item.product_id
        )
        .execute(&mut *tx)
        .await?;

        // 计算金额
        let item_total = product.price * Decimal::from(item.quantity);
        total_amount += item_total;

        order_items.push(OrderItem {
            product_id: item.product_id,
            quantity: item.quantity,
            price: product.price,
        });
    }

    // 2. 创建订单
    let order = sqlx::query_as!(
        Order,
        r#"
        INSERT INTO orders (user_id, status, total_amount)
        VALUES ($1, 'pending', $2)
        RETURNING *
        "#,
        req.user_id,
        total_amount
    )
    .fetch_one(&mut *tx)
    .await?;

    // 3. 创建订单项
    for item in &order_items {
        sqlx::query!(
            r#"
            INSERT INTO order_items (order_id, product_id, quantity, price)
            VALUES ($1, $2, $3, $4)
            "#,
            order.id,
            item.product_id,
            item.quantity,
            item.price
        )
        .execute(&mut *tx)
        .await?;
    }

    // 4. 提交事务
    tx.commit().await?;

    // 5. 发送订单创建事件 (异步)
    self.event_bus.publish(OrderCreated { order_id: order.id }).await;

    Ok(order)
}
```

##### 2.2.4 并发控制策略

| 场景 | 策略 | 实现 |
|------|------|------|
| 库存扣减 | 悲观锁 | `SELECT FOR UPDATE` |
| 订单状态变更 | 乐观锁 | `version` 字段 |
| 幂等性 | 唯一键 | `idempotency_key` |

```rust
/// 乐观锁更新订单状态
pub async fn update_status(
    &self,
    order_id: i64,
    event: OrderEvent,
    expected_version: i32,
) -> Result<Order, OrderError> {
    let current = self.find_by_id(order_id).await?
        .ok_or(OrderError::NotFound)?;

    // 检查状态转换是否合法
    let new_status = current.status
        .can_transition(&event)
        .ok_or(OrderError::InvalidTransition)?;

    // 乐观锁更新
    let result = sqlx::query_as!(
        Order,
        r#"
        UPDATE orders 
        SET status = $1, version = version + 1, updated_at = NOW()
        WHERE id = $2 AND version = $3
        RETURNING *
        "#,
        new_status as _,
        order_id,
        expected_version
    )
    .fetch_optional(&self.pool)
    .await?;

    result.ok_or(OrderError::ConcurrentModification)
}
```

---

#### 2.3 缓存模块

##### 2.3.1 缓存策略

| 数据类型 | 策略 | TTL | 更新方式 |
|----------|------|-----|----------|
| 用户信息 | Cache-Aside | 30min | 写时失效 |
| 商品列表 | Read-Through | 5min | 定时刷新 |
| 会话数据 | Write-Through | 30min | 写时更新 |
| 计数器 | Write-Behind | - | 批量写回 |

##### 2.3.2 Cache-Aside 实现

```rust
/// 缓存服务
pub struct CacheService {
    redis: RedisPool,
    local: Cache<String, Bytes>,  // 本地缓存 (moka)
}

impl CacheService {
    /// 获取或加载
    /// 
    /// 流程: 本地缓存 -> Redis -> 数据库
    pub async fn get_or_load<T, F, Fut>(
        &self,
        key: &str,
        ttl: Duration,
        loader: F,
    ) -> Result<T, CacheError>
    where
        T: Serialize + DeserializeOwned,
        F: FnOnce() -> Fut,
        Fut: Future<Output = Result<T, CacheError>>,
    {
        // 1. 本地缓存
        if let Some(bytes) = self.local.get(key) {
            return Ok(serde_json::from_slice(&bytes)?);
        }

        // 2. Redis
        if let Some(bytes) = self.redis.get(key).await? {
            // 回填本地缓存
            self.local.insert(key.to_string(), bytes.clone());
            return Ok(serde_json::from_slice(&bytes)?);
        }

        // 3. 加载数据
        let value = loader().await?;
        let bytes = serde_json::to_vec(&value)?;

        // 4. 写入缓存
        self.redis.set_ex(key, &bytes, ttl).await?;
        self.local.insert(key.to_string(), bytes.into());

        Ok(value)
    }

    /// 失效缓存
    pub async fn invalidate(&self, key: &str) -> Result<(), CacheError> {
        self.local.invalidate(key);
        self.redis.del(key).await?;
        Ok(())
    }
}
```

##### 2.3.3 缓存 Key 规范

```rust
/// 缓存 Key 构建器
pub struct CacheKey;

impl CacheKey {
    /// 用户信息: user:{id}
    pub fn user(id: i64) -> String {
        format!("user:{}", id)
    }

    /// 用户权限: user:{id}:permissions
    pub fn user_permissions(id: i64) -> String {
        format!("user:{}:permissions", id)
    }

    /// 订单: order:{id}
    pub fn order(id: i64) -> String {
        format!("order:{}", id)
    }

    /// 登录限流: login_limit:{ip}
    pub fn login_limit(ip: &str) -> String {
        format!("login_limit:{}", ip)
    }

    /// 幂等性: idempotent:{key}
    pub fn idempotent(key: &str) -> String {
        format!("idempotent:{}", key)
    }
}
```

---

### 3. 公共组件

#### 3.1 分页工具

```rust
/// 分页参数
#[derive(Debug, Deserialize)]
pub struct Pagination {
    #[serde(default = "default_page")]
    pub page: u32,
    #[serde(default = "default_limit")]
    pub limit: u32,
}

impl Pagination {
    pub fn offset(&self) -> i64 {
        ((self.page.saturating_sub(1)) * self.limit) as i64
    }

    pub fn limit(&self) -> i64 {
        self.limit.min(100) as i64  // 最大 100
    }
}

/// 分页结果
#[derive(Debug, Serialize)]
pub struct Page<T> {
    pub data: Vec<T>,
    pub total: i64,
    pub page: u32,
    pub limit: u32,
    pub total_pages: u32,
}

impl<T> Page<T> {
    pub fn new(data: Vec<T>, total: i64, pagination: &Pagination) -> Self {
        let total_pages = (total as f64 / pagination.limit as f64).ceil() as u32;
        Self {
            data,
            total,
            page: pagination.page,
            limit: pagination.limit,
            total_pages,
        }
    }
}
```

#### 3.2 ID 生成器

```rust
/// Snowflake ID 生成器
/// 
/// 结构: 1bit符号 + 41bit时间戳 + 10bit机器ID + 12bit序列号
/// 容量: 4096/ms per machine
pub struct IdGenerator {
    epoch: i64,          // 起始时间戳
    machine_id: i64,     // 机器 ID (0-1023)
    sequence: AtomicI64, // 序列号
    last_ts: AtomicI64,  // 上次时间戳
}

impl IdGenerator {
    pub fn next_id(&self) -> i64 {
        let mut ts = self.current_millis();
        let last = self.last_ts.load(Ordering::SeqCst);

        if ts == last {
            // 同一毫秒，序列号+1
            let seq = self.sequence.fetch_add(1, Ordering::SeqCst) & 0xFFF;
            if seq == 0 {
                // 序列号溢出，等待下一毫秒
                ts = self.wait_next_millis(last);
            }
        } else {
            // 新的毫秒，重置序列号
            self.sequence.store(0, Ordering::SeqCst);
        }

        self.last_ts.store(ts, Ordering::SeqCst);

        // 组装 ID
        ((ts - self.epoch) << 22) | (self.machine_id << 12) | self.sequence.load(Ordering::SeqCst)
    }
}
```

#### 3.3 重试工具

```rust
/// 重试配置
pub struct RetryConfig {
    pub max_attempts: u32,
    pub initial_delay: Duration,
    pub max_delay: Duration,
    pub multiplier: f64,
}

impl Default for RetryConfig {
    fn default() -> Self {
        Self {
            max_attempts: 3,
            initial_delay: Duration::from_millis(100),
            max_delay: Duration::from_secs(10),
            multiplier: 2.0,
        }
    }
}

/// 带重试的异步操作
pub async fn with_retry<T, E, F, Fut>(
    config: &RetryConfig,
    mut operation: F,
) -> Result<T, E>
where
    F: FnMut() -> Fut,
    Fut: Future<Output = Result<T, E>>,
    E: std::fmt::Debug,
{
    let mut delay = config.initial_delay;

    for attempt in 1..=config.max_attempts {
        match operation().await {
            Ok(result) => return Ok(result),
            Err(e) if attempt == config.max_attempts => return Err(e),
            Err(e) => {
                tracing::warn!(attempt, error = ?e, "操作失败，准备重试");
                tokio::time::sleep(delay).await;
                delay = (delay.mul_f64(config.multiplier)).min(config.max_delay);
            }
        }
    }

    unreachable!()
}
```

---

### 4. 错误处理

#### 4.1 错误分层

```rust
/// 领域错误 (业务错误)
pub enum DomainError {
    UserNotFound(i64),
    OrderNotFound(i64),
    InsufficientStock { product_id: i64, available: i32 },
    InvalidStateTransition { from: String, to: String },
}

/// 基础设施错误
pub enum InfraError {
    Database(sqlx::Error),
    Cache(redis::RedisError),
    External(reqwest::Error),
}

/// 应用错误 (对外暴露)
pub enum AppError {
    // 4xx
    BadRequest(String),
    Unauthorized,
    Forbidden,
    NotFound(String),
    Conflict(String),

    // 5xx
    Internal(String),
    ServiceUnavailable,
}

/// 错误转换
impl From<DomainError> for AppError {
    fn from(e: DomainError) -> Self {
        match e {
            DomainError::UserNotFound(_) => AppError::NotFound("用户不存在".into()),
            DomainError::OrderNotFound(_) => AppError::NotFound("订单不存在".into()),
            DomainError::InsufficientStock { .. } => AppError::Conflict("库存不足".into()),
            DomainError::InvalidStateTransition { .. } => AppError::Conflict("状态不允许此操作".into()),
        }
    }
}

impl From<InfraError> for AppError {
    fn from(e: InfraError) -> Self {
        tracing::error!(error = ?e, "基础设施错误");
        AppError::Internal("服务暂时不可用".into())
    }
}
```

#### 4.2 错误日志规范

```rust
// 业务错误：WARN 级别，包含上下文
tracing::warn!(
    user_id = %user_id,
    order_id = %order_id,
    error = "库存不足",
    "订单创建失败"
);

// 基础设施错误：ERROR 级别，包含完整错误链
tracing::error!(
    error = ?e,
    query = %sql,
    "数据库查询失败"
);

// 关键操作：INFO 级别，记录结果
tracing::info!(
    user_id = %user_id,
    order_id = %order.id,
    amount = %order.total_amount,
    "订单创建成功"
);
```

---

### 5. 测试策略

#### 5.1 测试金字塔

```
        /\
       /  \      E2E 测试 (10%)
      /----\     API 测试
     /      \
    /--------\   集成测试 (20%)
   /          \  Repository + Service
  /------------\
 /              \ 单元测试 (70%)
/________________\ Domain + Utils
```

#### 5.2 单元测试示例

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_order_status_transition() {
        // 合法转换
        assert_eq!(
            OrderStatus::Pending.can_transition(&OrderEvent::Pay),
            Some(OrderStatus::Paid)
        );

        // 非法转换
        assert_eq!(
            OrderStatus::Completed.can_transition(&OrderEvent::Cancel),
            None
        );
    }

    #[test]
    fn test_pagination_offset() {
        let p = Pagination { page: 1, limit: 20 };
        assert_eq!(p.offset(), 0);

        let p = Pagination { page: 3, limit: 20 };
        assert_eq!(p.offset(), 40);
    }

    #[test]
    fn test_cache_key_format() {
        assert_eq!(CacheKey::user(123), "user:123");
        assert_eq!(CacheKey::order(456), "order:456");
    }
}
```

#### 5.3 集成测试示例

```rust
#[tokio::test]
async fn test_create_order_with_insufficient_stock() {
    let pool = setup_test_db().await;
    let service = OrderService::new(pool.clone());

    // 准备：创建库存为 5 的商品
    let product = create_test_product(&pool, 5).await;

    // 执行：尝试购买 10 个
    let result = service.create_order(CreateOrderRequest {
        user_id: 1,
        items: vec![OrderItemRequest {
            product_id: product.id,
            quantity: 10,
        }],
    }).await;

    // 验证：应返回库存不足错误
    assert!(matches!(
        result,
        Err(OrderError::InsufficientStock { available: 5, requested: 10, .. })
    ));
}
```

---

## 质量检查清单

| 类别 | 检查项 |
|------|--------|
| 类型 | □ 核心结构体有定义 □ 枚举覆盖所有状态 □ 错误类型完整 |
| 算法 | □ 复杂度标注 □ 边界条件处理 □ 并发控制说明 |
| 数据 | □ 缓存策略明确 □ Key 规范统一 □ 索引设计合理 |
| 错误 | □ 分层清晰 □ 转换规则明确 □ 日志规范 |
| 测试 | □ 关键路径有用例 □ 边界条件覆盖 □ 错误场景覆盖 |

---

## 总结

| LLD 关注 | 不关注 |
|----------|--------|
| 函数签名和类型 | 产品需求背景 |
| 算法逻辑和复杂度 | 技术选型理由 |
| 状态机和流转规则 | 系统边界划分 |
| 缓存和并发策略 | 部署运维方式 |

> **核心原则**：LLD 是实现的蓝图，让开发者能**直接编码**，减少设计时的犹豫。