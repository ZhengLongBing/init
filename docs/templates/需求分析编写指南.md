# 需求分析编写指南

> 用户故事为主 · 简化用例为辅

---

## 1. 概述

本指南采用轻量化的需求管理方式，平衡文档价值与维护成本。

### 1.1 核心原则

- **够用就好**：文档服务于开发，不是为写而写
- **贴近代码**：需求描述要能直接映射到 Rust 实现
- **类型先行**：充分利用 Rust 类型系统表达业务约束
- **错误显式**：提前识别和定义错误场景

### 1.2 文档选型建议

| 文档类型 | 推荐度 | 适用场景 | Rust 后端关注点 |
|---------|-------|---------|----------------|
| **用户故事** | ⭐⭐⭐ 首选 | 所有功能需求 | API 端点、数据结构、性能要求 |
| **简化用例** | ⭐⭐ 补充 | 复杂业务流程 | 并发场景、状态机、事务边界 |
| **完整 SRS** | ⭐ 不推荐 | 外包/合规项目 | 维护成本高，小团队不适用 |

---

## 2. 用户故事编写指南

### 2.1 标准格式

```
作为 [角色]，我希望 [功能]，以便 [价值]
```

### 2.2 Rust 后端增强模板

在标准用户故事基础上，增加后端开发必需的技术细节：

| 字段 | 说明 |
|-----|------|
| **故事描述** | 作为 [角色]，我希望 [功能]，以便 [价值] |
| **API 定义** | HTTP 方法 + 路径 + 请求/响应结构 |
| **核心类型** | 关键 struct/enum 定义（伪代码或 Rust 类型） |
| **错误场景** | 预期的错误类型及 HTTP 状态码 |
| **性能要求** | 响应时间、吞吐量、并发数（可选） |
| **验收标准** | Given-When-Then 格式的可测试条件 |

### 2.3 完整示例

---

**用户故事：用户注册**

**故事描述**：作为新用户，我希望能通过邮箱注册账号，以便使用系统功能。

**API 定义**
```
POST /api/v1/users/register
Content-Type: application/json
```

**核心类型**
```rust
// 请求体
struct RegisterRequest {
    email: Email,        // 验证格式
    password: Password,  // 8-72字符，含大小写+数字
    username: String,    // 3-20字符
}

// 响应体
struct RegisterResponse {
    user_id: UserId,
    created_at: DateTime<Utc>,
}
```

**错误场景**
- `409 Conflict` - 邮箱已被注册
- `400 Bad Request` - 参数验证失败
- `429 Too Many Requests` - 注册频率限制

**性能要求**：P99 < 200ms

**验收标准**
1. Given 有效的注册信息，When 提交注册，Then 返回 201 + 用户 ID
2. Given 已存在的邮箱，When 提交注册，Then 返回 409 错误
3. Given 密码不符合规则，When 提交注册，Then 返回具体的验证错误信息

---

## 3. 简化用例编写指南

### 3.1 何时使用

仅在以下场景补充用例文档：

- **多步骤事务**：需要保证原子性的操作序列
- **并发处理**：涉及锁、竞态条件的场景
- **状态流转**：订单状态机、审批流程等
- **外部集成**：与第三方服务交互的复杂流程

### 3.2 简化格式

| 字段 | 内容 |
|-----|------|
| 用例名称 | 动词 + 名词（如：处理支付回调） |
| 触发条件 | 什么事件/请求触发此流程 |
| 主流程 | 编号步骤列表（正常情况） |
| 异常分支 | 步骤号 + 异常描述 + 处理方式 |
| 并发说明 | 锁策略、幂等性设计（Rust 特有） |
| 事务边界 | 哪些步骤在同一事务中 |

### 3.3 示例：处理支付回调

---

**用例名称**：处理支付回调

**触发条件**：支付网关发送 `POST /api/v1/payments/callback`

**主流程**
1. 验证签名（防篡改）
2. 解析回调数据，提取订单 ID 和支付状态
3. 查询订单，校验状态（必须是待支付）
4. 【事务开始】更新订单状态为已支付
5. 记录支付流水
6. 【事务结束】
7. 发送支付成功通知（异步）
8. 返回成功响应给支付网关

**异常分支**
- 1a. 签名验证失败 → 返回 401，记录安全日志
- 3a. 订单不存在 → 返回 200（幂等处理）
- 3b. 订单已支付 → 返回 200（幂等处理）
- 4-6. 事务失败 → 自动回滚，返回 500

**并发说明**
- 使用订单级乐观锁（version 字段）
- 回调处理需幂等：相同订单 ID 重复调用返回相同结果

---

## 4. Rust 后端特有考量

### 4.1 类型驱动设计

在需求阶段就考虑类型设计，利用 Rust 类型系统表达业务约束：

```rust
// 使用 newtype 模式封装业务类型
struct UserId(Uuid);      // 类型安全的 ID
struct Email(String);     // 验证过的邮箱
struct Money(Decimal);    // 金额类型

// 使用 enum 表达状态机
enum OrderStatus {
    Pending,                         // 待支付
    Paid { paid_at: DateTime },      // 已支付
    Shipped { tracking: String },    // 已发货
    Completed,                       // 已完成
    Cancelled { reason: String },    // 已取消
}
```

### 4.2 错误处理策略

需求文档中明确定义错误类型和映射关系：

| 错误类型 | HTTP 状态码 | 处理方式 |
|---------|------------|---------|
| `ValidationError` | 400 | 返回详细字段错误 |
| `AuthenticationError` | 401 | 清除会话，引导重新登录 |
| `AuthorizationError` | 403 | 提示权限不足 |
| `NotFoundError` | 404 | 资源不存在 |
| `ConflictError` | 409 | 提示冲突原因，建议重试 |
| `RateLimitError` | 429 | 返回重试时间 |
| `InternalError` | 500 | 记录详细日志，返回通用错误 |

### 4.3 性能与并发标注

在用户故事中标注性能敏感点：

| 标注 | 含义 | 实现提示 |
|-----|------|---------|
| `[HOT]` | 高频接口 | 需要缓存策略 |
| `[ASYNC]` | 异步处理 | 使用消息队列 |
| `[LOCK]` | 需要加锁 | 标注锁粒度 |
| `[BATCH]` | 批量操作 | 考虑分页/限流 |

---

## 5. 推荐工具与工作流

### 5.1 需求管理工具

| 工具 | 适用场景 | 推荐理由 |
|-----|---------|---------|
| **GitHub Issues** | 代码紧密集成 | 与 PR 关联，支持模板 |
| **Notion** | 文档+任务一体化 | 灵活的数据库视图 |
| **飞书文档** | 国内团队协作 | 实时协作，通知集成 |
| **Linear** | 追求效率的团队 | 极简设计，键盘优先 |

### 5.2 推荐工作流

```
需求收集 → 技术评审 → 补充用例(可选) → 开发实现 → 验收测试
    │           │            │              │           │
    ▼           ▼            ▼              ▼           ▼
 用户故事    补充类型     复杂流程时      按故事拆分    按验收标准
 卡片创建   错误/性能     才补充用例     关联 PR      编写测试
```

### 5.3 GitHub Issue 模板

```markdown
## 用户故事
作为 [角色]，我希望 [功能]，以便 [价值]

## API 定义
- 端点: `METHOD /path`
- 请求体: 
- 响应体: 

## 核心类型

// 在此定义关键数据结构


## 错误场景
- [ ] 400:
- [ ] 404:
- [ ] 409:

## 性能要求
- 响应时间:
- 并发标注:

## 验收标准
- [ ] Given... When... Then...
- [ ] Given... When... Then...
```

---

## 6. 快速参考卡片

### 用户故事检查清单

- [ ] 故事描述清晰，价值明确
- [ ] API 端点已定义（方法+路径+数据结构）
- [ ] 核心类型已设计（struct/enum）
- [ ] 错误场景已列举（状态码+处理方式）
- [ ] 性能要求已标注（如需要）
- [ ] 验收标准可测试

### 何时补充用例？

- ✓ 涉及数据库事务
- ✓ 需要处理并发/竞态
- ✓ 状态流转超过 3 个状态
- ✓ 涉及外部服务调用链
- ✓ 异常分支超过 3 种

### Rust 类型设计速查

```rust
// ID 类型 - 防止混用
struct UserId(Uuid);
struct OrderId(Uuid);

// 值对象 - 封装验证逻辑
struct Email(String);      // impl TryFrom<String>
struct Password(String);   // impl TryFrom<String>

// 状态机 - 编译期保证状态转换
enum State { A, B, C }
impl State {
    fn can_transition_to(&self, target: &State) -> bool { ... }
}

// 错误类型 - 统一错误处理
#[derive(thiserror::Error)]
enum AppError {
    #[error("validation failed: {0}")]
    Validation(String),
    #[error("not found: {0}")]
    NotFound(String),
}
```