# 系统架构设计编写指南

---

## 核心理念

### 以「决策」为中心

- 不是 "我们用了 X"，而是 "为什么选 X 而非 Y？"
- 记录约束条件和权衡过程
- 未来的你会感谢现在的记录

### 架构文档的三个读者

| 读者 | 关注点 | 需要什么 |
|------|--------|----------|
| 新成员 | 快速上手 | 全景图、模块职责、数据流 |
| 维护者 | 定位问题 | 边界划分、依赖关系、错误处理 |
| 未来的你 | 为什么这样设计 | 决策理由、放弃的方案、已知局限 |

### 小团队原则

- **够用就好**：不过度设计，留出演进空间
- **显式优于隐式**：约定写下来，不靠口口相传
- **一人能懂**：任何模块单人可理解和修改

---

## 文档结构

```
architecture.md
├── 1. 概述         → 30 秒理解系统
├── 2. 架构设计     → 模块 + 数据流
├── 3. 技术选型     → 为什么用这些
└── 4. 部署与运维   → 如何跑起来
```

---

## 完整模板

### 1. 概述

```markdown
# [项目名] 系统架构

> 一句话描述：[用户] 通过 [方式] 实现 [价值]

## 1. 概述

### 系统定位
这个系统解决什么问题？不解决什么问题？

### 核心场景
1. 场景A：用户做什么 → 系统响应什么
2. 场景B：...

### 质量要求
| 指标 | 目标 | 说明 |
|------|------|------|
| 响应时间 | P99 < 200ms | 核心 API |
| 可用性 | 99.9% | 月度 |
| 并发 | 1000 QPS | 初期目标 |
```

---

### 2. 架构设计

#### 2.1 系统全景图

```
┌─────────────────────────────────────────────┐
│                   客户端                     │
└─────────────────────┬───────────────────────┘
                      │ HTTPS
┌─────────────────────▼───────────────────────┐
│               API Gateway                   │
│             (认证/限流/路由)                  │
└─────────────────────┬───────────────────────┘
                      │
      ┌───────────────┼───────────────┐
      ▼               ▼               ▼
 ┌─────────┐    ┌─────────┐    ┌─────────┐
 │ 用户服务 │    │ 订单服务  │    │ 通知服务 │
 └────┬────┘    └────┬────┘    └────┬────┘
      │              │              │
      ▼              ▼              ▼
 ┌─────────┐    ┌─────────┐    ┌─────────┐
 │  用户DB  │    │  订单DB  │    │  Redis  │
 └─────────┘    └─────────┘    └─────────┘
```

#### 2.2 模块划分

| 模块 | 职责 | 边界 | 依赖 |
|------|------|------|------|
| `api` | HTTP 路由、请求校验 | 不含业务逻辑 | service |
| `service` | 业务逻辑编排 | 不直接访问 DB | repository |
| `repository` | 数据访问封装 | 只关心存取 | domain |
| `domain` | 核心实体和规则 | 无外部依赖 | - |

#### 2.3 目录结构

```
src/
├── main.rs                 # 入口
├── config.rs               # 配置
├── api/
│   ├── mod.rs
│   ├── routes.rs           # 路由定义
│   ├── handlers/           # 请求处理
│   └── middleware/         # 中间件
├── service/
│   └── user_service.rs
├── repository/
│   └── user_repo.rs
├── domain/
│   ├── user.rs             # 实体
│   └── error.rs            # 业务错误
└── infra/
    ├── db.rs               # 数据库
    └── cache.rs            # 缓存
```

#### 2.4 数据流示例

```
POST /users

api::handlers::create_user
  ├─ 解析 JSON → CreateUserRequest
  ├─ 校验字段
  └─ 调用 service
        │
service::user_service::create
  ├─ 检查用户名是否存在
  ├─ 密码哈希
  └─ 调用 repository
        │
repository::user_repo::insert
  └─ 执行 SQL INSERT → User
        │
响应: 201 Created + UserResponse
```

#### 2.5 错误处理

```rust
pub enum AppError {
    NotFound(String),
    Conflict(String),
    Validation(String),
    Internal(String),
}

impl IntoResponse for AppError {
    fn into_response(self) -> Response {
        let (status, msg) = match self {
            Self::NotFound(m)   => (StatusCode::NOT_FOUND, m),
            Self::Conflict(m)   => (StatusCode::CONFLICT, m),
            Self::Validation(m) => (StatusCode::BAD_REQUEST, m),
            Self::Internal(m)   => (StatusCode::INTERNAL_SERVER_ERROR, m),
        };
        (status, Json(json!({ "error": msg }))).into_response()
    }
}
```

---

### 3. 技术选型

#### 3.1 选型总览

| 层次 | 选择 | 备选 | 选择理由 |
|------|------|------|----------|
| Web 框架 | Axum | Actix-web | 类型安全、Tower 生态 |
| 数据库 | PostgreSQL | MySQL | JSONB、性能 |
| ORM | SQLx | Diesel | 编译时检查、原生 SQL |
| 缓存 | Redis | 内存 | 分布式、持久化 |
| 认证 | JWT | Session | 无状态、易扩展 |

#### 3.2 决策记录

**决策：选择 Axum**

| 维度 | Axum | Actix-web |
|------|------|-----------|
| 学习曲线 | ⭐⭐⭐ 平缓 | ⭐⭐ Actor 模型 |
| 类型安全 | ⭐⭐⭐ 充分利用 | ⭐⭐ 宏较多 |
| 生态整合 | ⭐⭐⭐ Tower/Hyper | ⭐⭐ 自有生态 |
| 极端性能 | ⭐⭐ 够用 | ⭐⭐⭐ 更快 |

**结论**：团队 2 人，学习成本优先，选 Axum。

---

**决策：选择 SQLx**

| 维度 | SQLx | Diesel |
|------|------|--------|
| 学习曲线 | ⭐⭐⭐ 会 SQL 即可 | ⭐⭐ 需学 DSL |
| 编译检查 | ⭐⭐⭐ SQL 语法 | ⭐⭐⭐ 类型安全 |
| 复杂查询 | ⭐⭐⭐ 原生 SQL | ⭐⭐ 需 raw SQL |
| 迁移工具 | ⭐⭐ 基础 | ⭐⭐⭐ 成熟 |

**结论**：团队熟悉 SQL，选 SQLx。

#### 3.3 依赖清单

```toml
[dependencies]
# Web
axum = "0.7"
tokio = { version = "1", features = ["full"] }
tower-http = { version = "0.5", features = ["cors", "trace"] }

# Database
sqlx = { version = "0.8", features = ["runtime-tokio", "postgres"] }

# Auth
jsonwebtoken = { version = "10", features = ["aws_lc_rs"] }
argon2 = "0.5"

# Serialization
serde = { version = "1", features = ["derive"] }
serde_json = "1"

# Observability
tracing = "0.1"
tracing-subscriber = "0.3"
```

---

### 4. 部署与运维

#### 4.1 环境配置

```bash
# .env.example
DATABASE_URL=postgres://user:pass@localhost/dbname
REDIS_URL=redis://localhost:6379
JWT_SECRET=your-secret-key-at-least-32-chars
RUST_LOG=info,sqlx=warn
```

#### 4.2 启动流程

```
1. 加载配置      → dotenvy
2. 初始化日志    → tracing
3. 连接数据库    → PgPool
4. 运行迁移      → sqlx migrate
5. 构建状态      → AppState
6. 启动服务      → axum::serve
```

#### 4.3 健康检查

```
GET /health → { "status": "ok", "version": "1.0.0" }
  ├─ 检查数据库连接
  └─ 检查 Redis 连接
```

#### 4.4 监控指标

| 指标 | 采集 | 告警阈值 |
|------|------|----------|
| 请求延迟 | tracing | P99 > 500ms |
| 错误率 | 日志 | > 1% |
| 连接池 | sqlx | 使用率 > 80% |

---

### 5. 演进规划

#### 当前边界

| 适用 | 不适用 |
|------|--------|
| 单实例部署 | 水平扩展 |
| QPS < 1000 | 高并发 |
| 数据量 < 100万 | 大数据 |

#### 演进路径

```
单体 → 读写分离 → 模块拆分 → 事件驱动
      (流量)     (复杂度)    (实时)
```

---

## 质量检查清单

| 类别 | 检查项 |
|------|--------|
| 完整性 | □ 系统全景图 □ 模块职责边界 □ 数据流说明 □ 错误处理策略 |
| 决策 | □ 选型有理由 □ 记录放弃方案 □ 说明已知局限 |
| 可操作 | □ 目录结构 □ 环境配置模板 □ 启动部署说明 □ 健康检查 |
| 可维护 | □ 新人 30 分钟理解 □ 模块单人可改 □ 有演进规划 |

---

## 表达技巧

### 架构图原则

| ✅ 好 | ❌ 避免 |
|-------|--------|
| 组件用方框，职责写里面 | 线条交叉 |
| 箭头标方向和协议 | 职责不明 |
| 分层清晰，对齐美观 | 缺少方向 |

### 决策记录格式

```markdown
### 决策：选择 X

**背景**：需要解决 Y 问题
**选项**：A / B / C
**决定**：选择 A
**理由**：1、2、3
**后果**：需接受 Z 限制
```

---

## 总结

| 优秀文档 | 避免 |
|----------|------|
| 全景感：新人快速建立心智模型 | 只有代码没有图 |
| 可追溯：理解为什么这样设计 | 只有结论没有理由 |
| 可操作：照文档能跑起来 | 过度设计 |
| 可演进：知道边界和方向 | 文档与代码脱节 |

> **核心原则**：架构文档不是炫技，而是**降低沟通成本**。